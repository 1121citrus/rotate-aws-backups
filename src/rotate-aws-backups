#!/usr/bin/env bash

# Yet another version of `rotate-backups` but this time applied to an AWS S3 backup archive bucket.
# Copyright (C) 2025 James Hanlon [mailto:jim@hanlonsoftware.com]
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# set -xv

ENV=${ENV:-${HOME:-/root}/.env}
[[ -r "${ENV}" ]] && source "${ENV}"

source "${COMMON_FUNCTIONS_FILE:-/usr/local/include/bash/common-functions}"

set -o errexit -o errtrace -o nounset -o pipefail
set +o xtrace +o verbose
is_true "${DEBUG:-false}" && set -o xtrace -o verbose

command=$(basename "${0}")

export AWS_CONFIG_FILE=${AWS_CONFIG_FILE:=/run/secrets/aws-config}
export AWS_EXTRA_ARGS=${AWS_EXTRA_ARGS:=}
export BUCKET=${AWS_S3_BUCKET_NAME:?Need AWS_S3_BUCKET_NAME}
export DELETE_IGNORED=${DELETE_IGNORED:=false}
export DRYRUN=${DRYRUN:=true}
export ROTATE_BACKUPS_EXTRA_ARGS=${ROTATE_BACKUPS_EXTRA_ARGS:=}
export TIMESTAMP_PATTERN=${TIMESTAMP_PATTERN:='(?P<year>\d{4})(?P<month>\d{2})(?P<day>\d{2})[Tt](?P<hour>\d{2})(?P<minute>\d{2})(?P<second>\d{2})'}

export HOURLY=${HOURLY:=24}
export DAILY=${DAILY:=7}
export WEEKLY=${WEEKLY:=4}
export MONTHLY=${MONTHLY:=6}
export YEARLY=${YEARLY:=always}

if is_true "${DRYRUN}"; then
    AWS_EXTRA_ARG=--dryrun ${AWS_EXTRA_ARGS}
fi

# Plan of action:
#   - collect arguments
#   - (within the initially empty work directory) create emoty file with the same corresponding
#     object within the bucket.
#   - run rotate-backups on our working directory
#   - remove the objects on S3 corresponding to the files deleted by rotate-backups
function rotate-aws-backups() {
    # Get a listing of the backup bucket and recreate its filename structure
    info scanning ${BUCKET}
    aws s3 ls "s3://${BUCKET}" | awk '{print $4}' | while read f; do
        touch "${WORKDIR}/${f}"
    done
    
    # Run rotate-backups on the temp directory files (having the same
    # names as the backups on S3. We examine the output and delete
    # object on S3 as needed.
    info begin rotate-backups
    /usr/local/bin/rotate-backups \
               --hourly="${HOURLY}" \
               --daily="${DAILY}" \
               --weekly="${WEEKLY}" \
               --monthly="${MONTHLY}" \
               --yearly="${YEARLY}" \
               --timestamp-pattern="${TIMESTAMP_PATTERN}" \
               ${ROTATE_BACKUPS_EXTRA_ARGS} \
               "${WORKDIR}" 2>&1 | \
    tee >(info >> /var/log/rotate-aws-backups/rotate-backups.log) | \
    egrep -i '(Deleting|Ignoring|Preserving)' | \
    awk '{ $1=$2=$3=$4=$5=""; print $0 }' | \
    sed "s|${WORKDIR}/||g" | \
    sed 's/[Dd]eleting/delete/' | \
    sed 's/[Ii]gnoring/ignore/' | \
    sed 's/[Pp]reserving/preserve/' | \
    while read message; do
        action=$(echo ${message} | awk '{print $1}' | tr '[A-Z]' '[a-z]')
        file=$(basename $(echo "${message}" | awk '{print $2}'))
        OBJECT=s3://${BUCKET}/${file}
        case "${action}" in
            delete)   info ${message}
                      if is_false "${DRYRUN}"; then
                          aws s3 rm ${AWS_EXTRA_ARGS} "${OBJECT}" | info
                      else
                          info DRYRUN s3 rm ${AWS_EXTRA_ARGS} "${OBJECT}"
                      fi
                      ;;
            preserve) info ${message}
                      ;;
            ignore)   if [[ "${DELETE_IGNORED}" = 'true' ]]; then \ 
                          info $(echo "${message}" | sed -E 's/Ignore/Delete/' | sed -E 's/ignore/delete/')
                          if is_false "${DRYRUN}"; then
                              aws s3 rm ${AWS_EXTRA_ARGS} "${OBJECT}" | info
                          else
                              info DRYRUN s3 rm ${AWS_EXTRA_ARGS} "${OBJECT}"
                          fi
                      else
                          ignore ${message}
                      fi
                      ;;
            *)        ignore ${message}
                      ;;
        esac
    done
    
}

# Create a work directory
WORKDIR=$(mktemp -d)
function cleanup() {
    rm -rf "${WORKDIR}" >/dev/null 2>&1 || true
}
trap cleanup EXIT

rotate-aws-backups "${@}"


